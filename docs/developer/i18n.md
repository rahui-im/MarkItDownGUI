# Internationalization (i18n)

## Overview

This guide covers the internationalization implementation for the MarkItDown GUI application, enabling multi-language support and localization for global users.

## Internationalization Strategy

### Supported Languages

#### Primary Languages (Phase 1)
- **English (en)** - Default language, US locale
- **Korean (ko)** - Korean locale support
- **Spanish (es)** - Spanish locale support  
- **French (fr)** - French locale support
- **German (de)** - German locale support

#### Extended Languages (Phase 2)
- **Japanese (ja)** - Japanese locale support
- **Chinese Simplified (zh-CN)** - Mainland China support
- **Chinese Traditional (zh-TW)** - Taiwan support
- **Portuguese (pt)** - Portuguese/Brazilian support
- **Italian (it)** - Italian locale support
- **Russian (ru)** - Russian locale support

### Localization Scope

#### User Interface Elements
- **Menu Items**: All menu text and shortcuts
- **Button Labels**: Action buttons and controls
- **Dialog Titles**: Window and dialog headers
- **Status Messages**: Progress and status indicators
- **Error Messages**: User-facing error text
- **Tooltips**: Contextual help text
- **Placeholder Text**: Input field hints

#### Documentation
- **User Manual**: Complete user guide translation
- **Help Content**: In-app help system
- **Error Descriptions**: Detailed error explanations
- **File Format Descriptions**: Format support information

#### Cultural Adaptations
- **Date Formats**: Locale-specific date representation
- **Number Formats**: Currency, decimal, and thousand separators
- **Text Direction**: RTL support for Arabic/Hebrew (future)
- **Cultural Colors**: Color meaning and preferences
- **File Path Conventions**: Platform-specific path display

## Technical Implementation

### PyQt6 Internationalization

#### Translation System Setup
```python
# main.py - Application startup with i18n
import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QTranslator, QLocale, QLibraryInfo

class MarkItDownApp(QApplication):
    def __init__(self, argv):
        super().__init__(argv)
        self.translator = QTranslator()
        self.setup_translations()
    
    def setup_translations(self):
        # Get system locale
        locale = QLocale.system().name()  # e.g., "ko_KR", "en_US"
        language_code = locale.split('_')[0]  # e.g., "ko", "en"
        
        # Load Qt's built-in translations first
        qt_translator = QTranslator()
        qt_translations_path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)
        
        if qt_translator.load(f"qt_{locale}", qt_translations_path):
            self.installTranslator(qt_translator)
        
        # Load application translations
        app_translator = QTranslator()
        translations_path = "resources/translations"
        
        if app_translator.load(f"markitdown_{language_code}", translations_path):
            self.installTranslator(app_translator)
            print(f"Loaded translation: {language_code}")
        else:
            print("Using default language: English")

if __name__ == "__main__":
    app = MarkItDownApp(sys.argv)
    # ... rest of application initialization
```

#### String Extraction and Management
```python
# markitdown_gui/core/i18n.py
from PyQt6.QtCore import QCoreApplication

def tr(text: str, context: str = None) -> str:
    """Translation wrapper function"""
    if context:
        return QCoreApplication.translate(context, text)
    else:
        return QCoreApplication.translate("MarkItDown", text)

# Usage throughout the application
from markitdown_gui.core.i18n import tr

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setup_ui()
    
    def setup_ui(self):
        # Translated UI elements
        self.setWindowTitle(tr("MarkItDown GUI Converter"))
        
        # Menu items
        file_menu = self.menuBar().addMenu(tr("&File"))
        file_menu.addAction(tr("&Open Folder..."), self.open_folder)
        file_menu.addAction(tr("&Settings"), self.show_settings)
        file_menu.addSeparator()
        file_menu.addAction(tr("E&xit"), self.close)
        
        edit_menu = self.menuBar().addMenu(tr("&Edit"))
        edit_menu.addAction(tr("Select &All"), self.select_all_files)
        edit_menu.addAction(tr("&Deselect All"), self.deselect_all_files)
        
        # Button labels
        self.convert_btn = QPushButton(tr("Convert Selected"))
        self.browse_btn = QPushButton(tr("Browse..."))
        self.cancel_btn = QPushButton(tr("Cancel"))
```

### Translation Files Structure

#### Translation Directory Organization
```
resources/translations/
├── markitdown_en.ts          # English (source language)
├── markitdown_ko.ts          # Korean translation
├── markitdown_es.ts          # Spanish translation
├── markitdown_fr.ts          # French translation
├── markitdown_de.ts          # German translation
├── compiled/
│   ├── markitdown_en.qm     # Compiled English
│   ├── markitdown_ko.qm     # Compiled Korean
│   ├── markitdown_es.qm     # Compiled Spanish
│   ├── markitdown_fr.qm     # Compiled French
│   └── markitdown_de.qm     # Compiled German
└── tools/
    ├── update_translations.py
    └── validate_translations.py
```

#### Translation Workflow

##### 1. String Extraction
```bash
# Extract translatable strings from Python source
pylupdate6 -verbose markitdown_gui/*.py markitdown_gui/ui/*.py -ts resources/translations/markitdown_en.ts
```

##### 2. Translation Management
```xml
<!-- markitdown_ko.ts - Korean translation file -->
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="ko">
<context>
    <name>MarkItDown</name>
    
    <message>
        <source>MarkItDown GUI Converter</source>
        <translation>MarkItDown GUI 변환기</translation>
    </message>
    
    <message>
        <source>&amp;File</source>
        <translation>파일(&amp;F)</translation>
    </message>
    
    <message>
        <source>&amp;Open Folder...</source>
        <translation>폴더 열기(&amp;O)...</translation>
    </message>
    
    <message>
        <source>&amp;Settings</source>
        <translation>설정(&amp;S)</translation>
    </message>
    
    <message>
        <source>Convert Selected</source>
        <translation>선택한 파일 변환</translation>
    </message>
    
    <message>
        <source>Browse...</source>
        <translation>찾아보기...</translation>
    </message>
    
    <message>
        <source>No files selected for conversion</source>
        <translation>변환할 파일이 선택되지 않았습니다</translation>
    </message>
    
    <message>
        <source>Conversion completed successfully</source>
        <translation>변환이 성공적으로 완료되었습니다</translation>
    </message>
    
    <!-- File format descriptions -->
    <message>
        <source>Office Documents</source>
        <translation>오피스 문서</translation>
    </message>
    
    <message>
        <source>PDF Files</source>
        <translation>PDF 파일</translation>
    </message>
    
    <message>
        <source>Image Files</source>
        <translation>이미지 파일</translation>
    </message>
    
    <!-- Error messages -->
    <message>
        <source>File conversion failed</source>
        <translation>파일 변환에 실패했습니다</translation>
    </message>
    
    <message>
        <source>Insufficient disk space</source>
        <translation>디스크 공간이 부족합니다</translation>
    </message>
    
    <message>
        <source>File not found or inaccessible</source>
        <translation>파일을 찾을 수 없거나 접근할 수 없습니다</translation>
    </message>
</context>

<context>
    <name>ProgressWidget</name>
    
    <message>
        <source>Processing...</source>
        <translation>처리 중...</translation>
    </message>
    
    <message>
        <source>%1 of %2 files converted</source>
        <translation>%2개 파일 중 %1개 변환 완료</translation>
    </message>
    
    <message>
        <source>Estimated time remaining: %1</source>
        <translation>예상 남은 시간: %1</translation>
    </message>
</context>

<context>
    <name>SettingsDialog</name>
    
    <message>
        <source>Settings</source>
        <translation>설정</translation>
    </message>
    
    <message>
        <source>Language</source>
        <translation>언어</translation>
    </message>
    
    <message>
        <source>Output Directory</source>
        <translation>출력 디렉토리</translation>
    </message>
    
    <message>
        <source>Theme</source>
        <translation>테마</translation>
    </message>
</context>
</TS>
```

##### 3. Compilation Process
```bash
# Compile .ts files to .qm files
lrelease resources/translations/markitdown_*.ts

# Alternative: Python-based compilation
python resources/translations/tools/compile_translations.py
```

### Dynamic Language Switching

#### Language Selection Interface
```python
# markitdown_gui/ui/settings_dialog.py
from PyQt6.QtWidgets import QDialog, QComboBox, QVBoxLayout, QLabel, QHBoxLayout, QPushButton
from PyQt6.QtCore import QSettings, pyqtSignal
from markitdown_gui.core.i18n import tr

class SettingsDialog(QDialog):
    language_changed = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.settings = QSettings()
        self.setup_ui()
        self.load_settings()
    
    def setup_ui(self):
        self.setWindowTitle(tr("Settings"))
        layout = QVBoxLayout()
        
        # Language selection
        lang_layout = QHBoxLayout()
        lang_layout.addWidget(QLabel(tr("Language:")))
        
        self.language_combo = QComboBox()
        self.language_combo.addItem("English", "en")
        self.language_combo.addItem("한국어", "ko")
        self.language_combo.addItem("Español", "es")
        self.language_combo.addItem("Français", "fr")
        self.language_combo.addItem("Deutsch", "de")
        
        self.language_combo.currentTextChanged.connect(self.on_language_changed)
        lang_layout.addWidget(self.language_combo)
        
        layout.addLayout(lang_layout)
        
        # OK/Cancel buttons
        button_layout = QHBoxLayout()
        self.ok_btn = QPushButton(tr("OK"))
        self.cancel_btn = QPushButton(tr("Cancel"))
        
        self.ok_btn.clicked.connect(self.accept)
        self.cancel_btn.clicked.connect(self.reject)
        
        button_layout.addWidget(self.ok_btn)
        button_layout.addWidget(self.cancel_btn)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
    
    def on_language_changed(self):
        current_data = self.language_combo.currentData()
        if current_data:
            self.language_changed.emit(current_data)
    
    def load_settings(self):
        current_lang = self.settings.value("language", "en")
        index = self.language_combo.findData(current_lang)
        if index >= 0:
            self.language_combo.setCurrentIndex(index)
    
    def save_settings(self):
        current_lang = self.language_combo.currentData()
        self.settings.setValue("language", current_lang)
```

#### Runtime Language Switching
```python
# markitdown_gui/core/language_manager.py
from PyQt6.QtCore import QObject, QTranslator, pyqtSignal, QCoreApplication
from PyQt6.QtWidgets import QApplication
import os

class LanguageManager(QObject):
    language_changed = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.current_language = "en"
        self.translator = QTranslator()
        self.app = QApplication.instance()
    
    def change_language(self, language_code: str):
        if language_code == self.current_language:
            return
        
        # Remove old translator
        if self.translator:
            self.app.removeTranslator(self.translator)
        
        # Load new translation
        translations_path = "resources/translations/compiled"
        translation_file = f"markitdown_{language_code}.qm"
        translation_path = os.path.join(translations_path, translation_file)
        
        if os.path.exists(translation_path):
            self.translator = QTranslator()
            if self.translator.load(translation_path):
                self.app.installTranslator(self.translator)
                self.current_language = language_code
                self.language_changed.emit(language_code)
                return True
        
        print(f"Translation not found: {translation_path}")
        return False
    
    def get_current_language(self) -> str:
        return self.current_language
    
    def get_available_languages(self) -> dict:
        return {
            "en": "English",
            "ko": "한국어",
            "es": "Español", 
            "fr": "Français",
            "de": "Deutsch"
        }

# Usage in main window
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.language_manager = LanguageManager()
        self.language_manager.language_changed.connect(self.on_language_changed)
        self.setup_ui()
    
    def on_language_changed(self, language_code: str):
        # Trigger UI refresh
        self.retranslate_ui()
    
    def retranslate_ui(self):
        # Update all translatable text elements
        self.setWindowTitle(tr("MarkItDown GUI Converter"))
        
        # Update menus
        self.file_menu.setTitle(tr("&File"))
        self.edit_menu.setTitle(tr("&Edit"))
        
        # Update buttons
        self.convert_btn.setText(tr("Convert Selected"))
        self.browse_btn.setText(tr("Browse..."))
        
        # Emit signal to child widgets to update their translations
        for child in self.findChildren(QWidget):
            if hasattr(child, 'retranslate_ui'):
                child.retranslate_ui()
```

### Localization Considerations

#### Cultural Adaptations

##### Date and Time Formatting
```python
# markitdown_gui/core/locale_utils.py
from PyQt6.QtCore import QLocale, QDateTime
from typing import Union

class LocaleFormatter:
    def __init__(self, language_code: str):
        self.locale = QLocale(language_code)
    
    def format_date(self, date: Union[QDateTime, str]) -> str:
        """Format date according to locale"""
        if isinstance(date, str):
            date = QDateTime.fromString(date, "yyyy-MM-dd hh:mm:ss")
        
        return self.locale.toString(date, QLocale.FormatType.ShortFormat)
    
    def format_file_size(self, size_bytes: int) -> str:
        """Format file size according to locale"""
        # Use locale-appropriate decimal separator
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            size_kb = size_bytes / 1024
            return f"{self.locale.toString(size_kb, 'f', 1)} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            size_mb = size_bytes / (1024 * 1024)
            return f"{self.locale.toString(size_mb, 'f', 1)} MB"
        else:
            size_gb = size_bytes / (1024 * 1024 * 1024)
            return f"{self.locale.toString(size_gb, 'f', 2)} GB"
```

##### Text Layout Adjustments
```python
# markitdown_gui/ui/components/localized_label.py
from PyQt6.QtWidgets import QLabel
from PyQt6.QtCore import Qt

class LocalizedLabel(QLabel):
    """Label that adjusts layout based on locale"""
    
    def __init__(self, text: str = "", language_code: str = "en"):
        super().__init__(text)
        self.language_code = language_code
        self.adjust_for_locale()
    
    def adjust_for_locale(self):
        # Adjust font size for languages with complex scripts
        if self.language_code in ['ja', 'zh-CN', 'zh-TW']:
            font = self.font()
            font.setPointSize(font.pointSize() + 1)
            self.setFont(font)
        
        # Adjust alignment for RTL languages (future support)
        if self.language_code in ['ar', 'he']:
            self.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        
        # Adjust word wrap for languages with long compound words
        if self.language_code in ['de', 'fi']:
            self.setWordWrap(True)
```

### Translation Automation Tools

#### Translation Validation Script
```python
# resources/translations/tools/validate_translations.py
import xml.etree.ElementTree as ET
import os
import sys

def validate_translation_file(ts_file_path: str) -> dict:
    """Validate translation file for completeness and consistency"""
    results = {
        'total_strings': 0,
        'translated_strings': 0,
        'untranslated_strings': [],
        'empty_translations': [],
        'placeholder_issues': []
    }
    
    try:
        tree = ET.parse(ts_file_path)
        root = tree.getroot()
        
        for context in root.findall('context'):
            for message in context.findall('message'):
                source = message.find('source')
                translation = message.find('translation')
                
                if source is not None:
                    results['total_strings'] += 1
                    source_text = source.text or ""
                    
                    if translation is not None and translation.text:
                        results['translated_strings'] += 1
                        
                        # Check for placeholder consistency
                        source_placeholders = set(re.findall(r'%\d+', source_text))
                        trans_placeholders = set(re.findall(r'%\d+', translation.text))
                        
                        if source_placeholders != trans_placeholders:
                            results['placeholder_issues'].append({
                                'source': source_text,
                                'translation': translation.text,
                                'expected_placeholders': source_placeholders,
                                'actual_placeholders': trans_placeholders
                            })
                    else:
                        results['untranslated_strings'].append(source_text)
                        
                        if translation is not None and not translation.text:
                            results['empty_translations'].append(source_text)
    
    except ET.ParseError as e:
        print(f"Error parsing {ts_file_path}: {e}")
        return None
    
    return results

def main():
    translations_dir = "resources/translations"
    
    for filename in os.listdir(translations_dir):
        if filename.endswith('.ts') and filename != 'markitdown_en.ts':
            file_path = os.path.join(translations_dir, filename)
            print(f"\nValidating {filename}...")
            
            results = validate_translation_file(file_path)
            if results:
                completion = (results['translated_strings'] / results['total_strings']) * 100
                print(f"  Completion: {completion:.1f}%")
                print(f"  Translated: {results['translated_strings']}/{results['total_strings']}")
                
                if results['untranslated_strings']:
                    print(f"  Untranslated: {len(results['untranslated_strings'])} strings")
                
                if results['placeholder_issues']:
                    print(f"  Placeholder Issues: {len(results['placeholder_issues'])}")
                    for issue in results['placeholder_issues'][:3]:  # Show first 3
                        print(f"    - {issue['source'][:50]}...")

if __name__ == "__main__":
    main()
```

#### Automated Translation Update
```bash
#!/bin/bash
# resources/translations/tools/update_all_translations.sh

echo "Updating translation files..."

# Extract strings from source code
echo "Extracting translatable strings..."
pylupdate6 -verbose markitdown_gui/*.py markitdown_gui/ui/*.py markitdown_gui/ui/components/*.py -ts resources/translations/markitdown_en.ts

# Update existing translation files
for lang in ko es fr de; do
    echo "Updating $lang translation..."
    pylupdate6 -verbose markitdown_gui/*.py markitdown_gui/ui/*.py markitdown_gui/ui/components/*.py -ts resources/translations/markitdown_$lang.ts
done

# Validate translations
echo "Validating translations..."
python resources/translations/tools/validate_translations.py

# Compile updated translations
echo "Compiling translations..."
mkdir -p resources/translations/compiled
for ts_file in resources/translations/*.ts; do
    base_name=$(basename "$ts_file" .ts)
    lrelease "$ts_file" -qm "resources/translations/compiled/$base_name.qm"
done

echo "Translation update complete!"
```

## Testing Internationalization

### Automated i18n Testing
```python
# tests/test_i18n.py
import pytest
from PyQt6.QtWidgets import QApplication
from markitdown_gui.core.language_manager import LanguageManager
from markitdown_gui.ui.main_window import MainWindow

class TestInternationalization:
    def test_language_switching(self, qtbot):
        """Test runtime language switching"""
        app = QApplication.instance()
        if not app:
            app = QApplication([])
        
        window = MainWindow()
        qtbot.addWidget(window)
        
        manager = LanguageManager()
        
        # Test switching to Korean
        result = manager.change_language("ko")
        assert result is True
        assert manager.get_current_language() == "ko"
        
        # Test switching to invalid language
        result = manager.change_language("invalid")
        assert result is False
    
    def test_translation_completeness(self):
        """Test that all required strings have translations"""
        languages = ["ko", "es", "fr", "de"]
        
        for lang in languages:
            ts_file = f"resources/translations/markitdown_{lang}.ts"
            results = validate_translation_file(ts_file)
            
            # Ensure minimum 80% completion for release
            completion_rate = results['translated_strings'] / results['total_strings']
            assert completion_rate >= 0.8, f"{lang} translation only {completion_rate*100:.1f}% complete"
    
    def test_placeholder_consistency(self):
        """Test that placeholder strings are consistent across translations"""
        # This would test that %1, %2, etc. placeholders are preserved
        pass
    
    @pytest.mark.parametrize("language", ["ko", "es", "fr", "de"])
    def test_ui_layout_with_language(self, qtbot, language):
        """Test UI layouts with different languages"""
        app = QApplication.instance()
        if not app:
            app = QApplication([])
        
        manager = LanguageManager()
        manager.change_language(language)
        
        window = MainWindow()
        qtbot.addWidget(window)
        
        # Ensure UI elements are still visible and properly sized
        assert window.isVisible()
        assert window.convert_btn.isVisible()
        assert not window.convert_btn.text().isEmpty()
```

### Manual Testing Checklist

#### Language Switching
- [ ] Language selection in settings
- [ ] Immediate UI update after language change
- [ ] Settings persistence across sessions
- [ ] Proper fallback to English for missing translations

#### UI Layout Testing
- [ ] Text doesn't overflow containers
- [ ] Buttons remain properly sized
- [ ] Dialog boxes adjust to content
- [ ] Menu items display correctly
- [ ] Tooltips show in selected language

#### Functional Testing
- [ ] All features work in each language
- [ ] Error messages appear in correct language
- [ ] File paths display correctly
- [ ] Date/time formats follow locale conventions

## Related Documentation

- 🎨 [UI Guidelines](ui-guidelines.md) - Interface design principles
- ♿ [Accessibility](accessibility.md) - Accessibility implementation  
- 🎨 [Theme System](theming.md) - Custom themes and styling
- 🧪 [Testing Guide](testing.md) - Comprehensive testing approach

---

**Last Updated**: 2025-01-13  
**Version**: 1.0.0  
**Status**: 🚧 In Development